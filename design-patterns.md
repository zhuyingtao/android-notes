# 设计模式

> 详细阅读系列文章： https://refactoringguru.cn/design-patterns

## 一、概述

### 1. 设计模式是什么

设计模式是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。

模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案。

算法更像是菜谱：提供达成目标的明确步骤。而模式更像是蓝图：你可以看到最终的结果和模式的功能，但需要自己确定实现步骤。

### 2. 设计模式的历史

《[设计模式： 可复用面向对象软件的基础](https://refactoringguru.cn/gof-book)》，简称为“四人组（Gang of Four，GoF）的书”，并且很快进一步简化为“GoF 的书”，系统介绍了 23 种设计模式。

### 3. 为什么要学习设计模式

- 设计模式是针对软件设计中常见问题的工具箱，其中的工具就是各种**经过实践验证的解决方案**。
- 设计模式定义了一种让你和团队成员能够更高效沟通的通用语言。

## 二、设计模式分类

- **创建型模式**提供创建对象的机制， 增加已有代码的灵活性和可复用性。
- **结构型模式**介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。
- **行为模式**负责对象间的高效沟通和职责委派。

### 1. 创建型模式

这类模式提供创建对象的机制，能够提升已有代码的灵活性和可复用性。

#### 工厂方法模式（Factory Method）

工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用（即使用`new`运算符）。

![img](assets/Untitled/(null)-20220811001702081.(null))

1. **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
2. **具体产品** （Concrete Products） 是产品接口的不同实现。
3. **创建者** （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。

注意，尽管它的名字是创建者，但它最主要的职责并**不是**创建产品。一般来说，创建者类包含一些与产品相关的核心业务逻辑。工厂方法将这些逻辑处理从具体产品类中分离出来。

1. **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

优缺点

- 你可以避免创建者和具体产品之间的紧密耦合。
- *单一职责原则*。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。
- *开闭原则*。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。
- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。 

#### 抽象工厂模式（Abstract Factory）

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

![img](assets/Untitled/(null)-20220811001702000.(null))

1. **抽象产品** （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。
2. **具体产品** （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。
3. **抽象工厂** （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。
4. **具体工厂** （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的*抽象*产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 **客户端** （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。

优缺点

- 你可以确保同一工厂生成的产品相互匹配。
-  你可以避免客户端和具体产品代码的耦合。
-  *单一职责原则*。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
-  *开闭原则*。 向应用程序中引入新产品变体时， 你无需修改客户端代码。
-  由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

#### 生成器模式（Builder）

**生成器模式**是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。

如果一个类的构造方法拥有大量输入参数，但这些参数并不一定每次都用的上，这使得对于构造方法的调用十分不简洁。这个时候，生成器模式将会派上用场。使用生成器模式可以避免“重叠构造方法”的出现。

![img](assets/Untitled/(null))

1. **生成器** （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
2. **具体生成器** （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
3. **产品** （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
4. **主管** （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
5. **客户端** （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。

#### 原型模式

##### 意图

**原型模式**是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

##### 问题

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

但会有两个问题：

1. 私有成员变量问题。有些对象可能拥有私有成员变量，这在外部是不可见的。
2. 多态问题。有时只知道对象所实现的接口，并不知道具体所属的类。

##### 解决方案

